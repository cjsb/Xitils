
# Xitils の各クラスの概要

## アプリケーション
### App.h
この中で定義されている `XApp` クラスを継承することで、
固有の初期化/終了処理、更新処理、また描画処理を行うアプリケーションが定義できます。

レイトレーシングなどの重い処理に対応するため、
描画処理はメインスレッド上で行われる一方で
更新処理は別スレッド上で動作します。

更新処理と描画処理の間でデータの受け渡しは、
渡したいデータをメンバに持つクラス (Frame と呼ぶ) のインスタンスを受け渡すことで行われます。
使用する Frame クラスの指定は、`XApp` クラスを継承した子クラスを定義する際にテンプレート引数として渡します。
このとき、更新→描画の受け渡しに使用する Frame と、描画→更新の受け渡しに使用する Frame のクラスは個別に指定する必要があることに注意してください。
(ふたつを区別する場合、特に後者は UI Frame と呼ばれます。)

#### メモ
- 実際にこれを使っている様子は `Sandbox\SimpleWindow` を参照すると分かりやすです。
- Frame のインスタンスがもつデータは、内部的にはバッファを通じてスレッド間でやり取りされます。
  バッファへのデータコピーは Frame インスタンス間での代入として行われるので、
  Frame のクラスは代入ですべてのデータがコピーされるようにしておく必要があります。
  つまり、Frame クラスはポインターを含まないようにするか、
  もしくは代入をオーバーライドしてデータがディープコピーされるようにしなければなりません。

## ベクトルと行列
### Vector.h
2, 3, 4 次元のベクトルそれぞれについて、int 版と float 版を用意しています。
(`Vector2i, Vector2f, ...`)

SIMD 処理に対応しています。

#### メモ
- クラスにテンプレート引数が `T`, `T_SIMD`, `T_SIMDMASK` の 3 つもあってややこしいですが、
  `T` はデータが int か float かを表し、
  `T_SIMD` と `T_SIMDMASK` は libsimdpp (SIMD 用ライブラリ) におけるレジスタ上でのデータ型 (とそのマスクの型) を表します。
- ベクトルを正規化する `normalize` など一部の関数については、
  メンバ関数版 (例: `v.normalize();`) と通常の関数版 (例: `normalize(v);`) が用意してあります。
  この場合、呼び出したときに関数を適用したインスタンスに対して変化を与えるものがメンバ関数、変化を与えないものが通常の関数として定義されています。
  (例: `v.normalize();` は `v` を正規化してその値を返すが、`normalize(v);` は `v` が正規化された値を返すだけで `v` 自体は不変。)
- `v.length();` など変化を与えるオプションが考えられない関数についてはメンバ関数として定義されています。

### Matrix.h
4x4 の行列を表すクラス `4x4Matrix` が定義されています。

#### メモ
- SIMD 処理にはまだ未対応です。

## テクスチャ
### Texture.h
`Texture` クラスは画像データを読み込んでテクスチャとして使用することを可能にします。

#### メモ
- 透明度があるテクスチャを読み込むと落ちます。(！)
- 指定したパスが間違っているなどで画像ファイルが読み込めないと落ちます。(！)

## マテリアル
### Material.h
`Material` クラスを継承して様々な素材を表すクラスの作成が可能です。
子クラスでは BSDF や PDF などを表す関数を定義します。

#### メモ
- BSDF の評価のみを行う関数と、BSDF を評価しつつ方向のサンプルを行う関数とでは、戻り値の次元が違うので注意。
    - 前者は BSDF(ωi, ωo) × cosθ で、後者は BSDF(ωi, ωo) × cosθ / P(ωi)
- スペキュラのオブジェクトの場合、BSDF のみを評価する関数と PDF を評価する関数ではその戻り値がデルタ関数になります。
  この場合は、子クラスでそれらの関数の実装を行う必要はありません。
   - スペキュラの場合には、パストレーサー側でそれらの関数の呼び出しが迂回されるためです。
   - 親クラスでは `NOT_IMPLEMENTED` マクロを使った仮の定義がされています。
     スペキュラ以外の素材において、必要な関数が子クラスで定義されていない場合にはその仮定義された関数が呼び出され実行時エラーになります。
- BSDF や PDF の評価は、オブジェクト座標系上で計算されます。
    - 法線、接線、従接線からなる局所座標系上で計算した方が楽な場合もあるので、あとで仕様変更されるかもしれません。

## ジオメトリ

### Bounds.h
2, 3 次元の領域を表すクラスについて、それぞれ int 版と float 版を用意しています。
(`Bounds2i, Bounds2f, ...`)

SIMD 処理に対応しています。

#### メモ
- クラスのテンプレート引数は Vector.h の場合と同様です。


### Geometry.h
各種ジオメトリが継承するべきインタフェースとして `Geometry` クラスを定義しています。

`Geometry` クラスを継承したクラスは

- AABB の取得
- 表面積の取得
- レイとの交差判定

を実装します。

### Shape.h
`Geometry` クラスを継承した `Shape` クラスの宣言を行っています。
`Shape` クラスは後述する `Object` クラスが参照するもので、
オブジェクト座標系で定義されたジオメトリ形状を表します。

同ヘッダファイル内には `Shape` の実装のひとつとして、球を表す `Sphere` クラスが定義されています。

#### メモ
- `Shape` とレイの交差判定は、オブジェクト座標系上で計算されます。

### TriangleMesh.h
`TriangleMesh` も `Shape` の実装のひとつです。
後述する `TriangleIndexed` が複数集まって構成されているメッシュを表します。

複数の `TriangleIndexed` とレイとの交差判定を高速化するため、
後述する `AccelerationStructure` を使用しています。

### TriangleIndexed.h
`TriangleIndexed` は `Geometry` クラスを継承したクラスで、
メッシュ中のひとつの三角形を表します。

#### メモ
- `Shape` ではなく `Geometry` を継承しているのは、
  `TriangleIndexed` が `Object` から参照されるのではなく、
  三角形が所属する `TriangleMesh` からしか参照されないためです。
- この辺の関係性がややこしいのであとで修正するかもしれません。(命名が良くない気がする)
- `TriangleIndexed` も、オブジェクトのローカル座標上で定義されます。

### Transform.h
`Transform` クラスは、ワールド座標系とオブジェクト座標系の変換を表します。
これは、後述する `Object` インスタンスのワールド座標上への配置に使用されます。

### Object.h
`Object` クラスは `Geometry` クラスを継承し、
シーンのワールド座標系上に配置された物体を表します。

物体間で形状のデータを共有できるように (インスタンシングできるように)、
形状データは `Shape` への参照として保持されます。
このローカル座標系で定義される `Shape` をワールド座標系への配置する際には `Transform` が用いられます。

形状に対して適用する素材も `Object` において指定され、
これは形状の場合と同様に `Material` への参照として保持されます。

#### メモ
- `Object` とレイの交差判定は、ワールド座標系上で計算されます。

## シーン
### Scene.h
`Scene` クラスは描画対象となるシーンを表します。

シーン上の `Object` とレイの交差判定の高速化のために `AccelerationStructure` が使用されます。

### メモ
- シーンへの `Object` の登録は `addObject` 関数で行い、
  すべての `Object` の追加が終わった後には `buildAccelerationStructure` 関数を実行して `AccelerationStructure` を初期化する必要があります。

### Camera.h
カメラを表す `Camera` クラスが実装されています。

現在はシンプルなピンホールカメラと平行投影カメラが実行されています。

### SkyShpere.h
`SkySphere` は IBL に使用する天球を表すクラスです。

以下のページの .hdr 画像を読み込むことを想定しています。

http://www.pauldebevec.com/Probes/

#### メモ
- 指定したパスが間違っているなどで画像ファイルが読み込めないと落ちます。(！)

## 交差判定
### Ray.h
`Ray` クラスはレイを表します。

### Interaction.h
物体とレイの交点を表すクラスが定義されています。
現在は、物体の表面とレイの交点を表す `SurfaceInteraction` クラスのみが実装されています。

#### メモ
- 関与媒質内での交点を表すクラスは後で追加予定です。

### AccelerationStructure.h
`AccelerationStructure` は、
`Geometry` クラスのインスタンス群とレイの交差判定を高速化します。

ヘッダ中の

```using AccelerationStructure = _BVH;```

の部分を変更することで使用する実装を選択可能です。
現在の時点で、

- `_BVH`
- `_NaiveAccelerationStructure` (高速化を行わないもの)

が実装されています。

## パストレーサー
### PathTracer.h
各種パストレーサーが実装されています。

- `NaivePathTracer` クラス: BRDFからのインポータンスサンプリングを行うパストレーサー。
- `StandardPathTracer` クラス: BRDFからのサンプリングと NEE の MIS を行うパストレーサー。

## マルチスレッド
### RenderTarget.h
`RenderTarget` クラスはレンダリングのターゲットになる画像を表します。

画像は小さなタイルに分割され、
各サンプリングにおいてはタイル単位での並列な処理が行われます。

#### メモ
- `RenderTarget` はレンダリング結果のトーンマップも担当していますが、現在は単純にクランピングを行っているだけです。

## 乱数
### Sampler.h
`Sampler` は乱数を発生させるクラスです。

ヘッダ中の

```using Sampler = _SamplerMersenneTwister;```

の部分を変更することで使用する実装を選択可能です。
現在の時点で、

- `_SamplerMersenneTwister`
- `_SamplerXORShift` (バグあり)

が実装されています。

#### メモ
- `Sampler` はスレッドセーフな挙動を保証しないため、
  `RenderTarget` の各タイルでは
  異なる値をシードとした `Sampler` インスタンスが作成されそれらが個別に使用されます。

## その他
### Utils.h
諸々のファイルが共通して使用するマクロ、インクルード、関数などが定義されています。

### VonMisesFisherDistribution.h
`VonMisesFisherDistribution` クラスは von Mises-Fisher 分布の作成、
またそこからのサンプリングを行うためのクラスです。

### Table.h
多変数関数のテーブル化を行うためのクラスですが、実装途中です。


## 全体的なことにまつわるメモ
- 基本的にはポインタを使用する際はスマートポインタを用いるようにしていますが、
  マルチスレッドで動作し、かつポインタのコピーが発生する場所では生のポインタを用いるようにしています。
    - スマートポインタを用いると、参照カウントをスレッドセーフに変化させるために速度が低下する。
    - 具体的に使用している箇所は、例えば `SurfaceInteraction` が持つ `Object` への参照など。

- 関数の引数について、値渡しとポインタと参照の使い分けについては以下のように行っています。
    - 型がプリミティブ型で、入力としてのみ使用する → 値渡し
    - 型がクラスまたは構造体で、入力としてのみ使用する → const を付けた参照渡し
    - 出力としてのみ使用する (値が初期化済みなのを前提にしない) → ポインタ渡し
    - 入力と出力どちらにも使用する (値が初期化済みなのを前提にする) → 参照渡し